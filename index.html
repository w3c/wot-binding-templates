LevelData<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Web of Things (WoT) Protocol Binding Templates</title>
    <script class="remove" async="" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script class="remove">
          var respecConfig = {
              specStatus:     "ED"
            , processVersion: 2017
            , shortName:      "wot-binding-templates"
            , copyrightStart: 2017
            , wg:             "Web of Things Working Group"
            , wgURI:          "https://www.w3.org/WoT/WG/"
            , wgPublicList:   "public-wot-wg"
            , edDraftURI:     "https://w3c.github.io/wot-binding-templates/"
            , githubAPI:      "https://api.github.com/repos/w3c/wot-binding-templates"
            , issueBase:      "https://www.github.com/w3c/wot-binding-templates/issues"
            , editors: [
                {
                  name:       "Michael Koster"
                , w3cid:      "00000"
                , company:    "SmartThings"
                , companyURL: "https://www.smartthings.com/"
                }
              ]
            , otherLinks: [
                {
                  key: "Contributors"
                , data: [
                    {
                      value: "In the GitHub repository"
                    , href: "https://github.com/w3c/wot-architecture/graphs/contributors"
                    }
                  ]
                }
              , {
                  key: "Repository",
                  data: [
                    {
                      value: "We are on GitHub",
                      href: "https://github.com/w3c/wot-binding-templates/"
                    }
                  , {
                      value: "File a bug",
                      href: "https://github.com/w3c/wot-binding-templates/issues"
                    }
                  ]
                }
              ]
            , localBiblio: {
                "CoRE-RD" : {
                  href: "https://tools.ietf.org/html/draft-ietf-core-resource-directory-11"
                , title: "CoRE Resource Directory"
                , status:    "Internet-Draft"
                , publisher: "IETF"
                , date: "03 July 2017"
                }
              }
            };
    </script>
  </head>
  <body>

    <section id="abstract">
      <p>
        W3C Web of Things enables applications to interact with and orchestrate
        connected Things at Web scale. The standardized abstract interaction
        model exposed by the WoT Thing Description enables applications to scale and
        evolve independently of the individual Things.
      </p>
      <p>
        Many network-level protocols and standards for connected Things have
        already been developed, and have millions of devices deployed in the
        field today. These standards are converging on a common set of transport
        protocols and transfer layers, but each has peculiar content formats,
        payload schemas, and data types.
      </p>
      <p>
        Despite using unique formats and data models, the high-level interactions
        exposed by most connected things can be modeled using the Property, Action,
        and Event interaction patterns of the WoT Thing Description.
      </p>
      <p>
        Protocol Binding Templates enable a Thing Description to be adapted to
        the specific protocol usage across the different standards. This is done
        through additional descriptive vocabulary that is used in the
        Thing Description.
      </p>
      <p>
        This document describes the initial set of design pattern and vocabulary
        extensions to the WoT Thing Description that make up the Protocol Binding
        Templates. It is expected over time that additional protocols will be
        accommodated by further extending the Binding Templates, adding new
        vocabulary and new design patterns.
      </p>
    </section>


    <section id="sotd">
      <p class="ednote" title="The W3C WoT WG is asking for feedback">
        Please contribute to this draft using the
        <a href="https://github.com/w3c/wot-binding-templates/issues">GitHub Issue</a>
        feature of the <a href="https://github.com/w3c/wot-binding-templates/">
        WoT Protocol Binding Templates</a> repository.
        For feedback on security and privacy considerations, please use the
        <a href="https://github.com/w3c/wot-security/issues">WoT Security and Privacy</a>
        Issues, as they are cross-cutting over all our documents.
      </p>
    </section>


    <section>
      <h1>Introduction</h1>
      <p>
        Protocol Binding Templates consist of reusable vocabulary and design
        pattern extensions to the WoT Thing Description format that enable an
        application client to interact, using a consistent interaction model,
        with Things that expose diverse protocols and protocol usage.
      </p>

      <section>
        <h2>Protocol Adaptation</h2>
        <p>
          Protocol Binding Templates enable clients to adapt to the underlying
          protocol and network-facing API constructions. Once the base protocol
          (e.g., HTTP, CoAP, MQTT, etc.) is identified, the following adaptions
          specifiy the particular use within the given Platform.
        </p>

        <section>
          <h3>Protocol Methods and Options</h3>
          <p>
            Most protocols have a relatively small set of methods that define
            the message type, the semantic intention of the message. As a starting
            point, a superset of REST and PubSub can cover most standard
            communication patterns. Common methods are GET, PUT, POST, DELETE,
            PATCH, PUBLISH, and SUBSCRIBE.
          </p>
          <p>
            The protocol methods are mapped to the abstract WoT Interaction verbs
            <code>readProperty</code>, <code>writeProperty</code>,
            <code>observeProperty</code>, <code>invokeAction</code>,
            <code>subscribeEvent</code>, <code>unsubscribeEvent</code>.
            <!-- modifyAction, cancelAction is still undefined -->
          </p>
          <p>
            Possible protocol options are also specified in the Protocol Binding.
            They are used to select transfer modes, to request notifications from
            observable resources, or otherwise extend the semantics of the protocol
            methods.
          </p>
        </section>

        <section>
          <h3>Media Types</h3>
          <p>
            Maximum use should be made of IANA-registered Media Types (e.g.,
            <code>application/json</code>) in order to decouple applications from
            connected Things. Standard bridges and translations from proprietary
            formats to Web-friendly languages such as JSON and XML are part of the
            adaptation needed.
          </p>
          <p>
            WoT Protocol Bindings depend on consistent use of Media Types for
            customization of the upper layers.
          </p>
        </section>

        <section>
          <h3>Payload Structure</h3>
          <p>
            Data serialized to a standard Media Type still remains in a structure
            specific to the Platform data model and needs to be understood by
            clients (cf. various types of JSON documents).
          </p>
          <p>
            The data definition language of <code>DataSchema</code>
            elements, described in [TD], allows for describing arbitrary
            structures by nesting of arrays and objects. Constants and
            variable specifications may be intermixed.
          </p>
        </section>

        <section>
          <h3>Data Types and Value Constraints</h3>
          <p>
            Simple data types and value constraints are currently used in a layered
            and descriptive way in WoT Thing Description. Additional forms of
            constraints are available to help adapt to the underlying data types.
            A Platform-specific 8-bit unsigned integer, for instance, can be defined
            as Integer with a minimum of 0 and maximum of 255; the system-specific
            representation (e.g., exact number of bits) on server and client is not
            relevant for interoperability.
          </p>
        </section>
      </section>
    </section>

    <section id="binding-overview" class="informative">
      <h1>Protocol Binding Templates Overview</h1>
      <p>
        This section describes the mechanisms of protocol binding templates with
        examples.
      </p>

      <section id="Data Schema">
        <h2>Data Schema</h2>
        <p>
          The <code>DataSchema</code> elements describe the payload structure and
          data items that are passed between client and server during interactions.
        </p>

        <section id="payload-structure">
          <h2>Payload Structure</h2>
          <p>
            Payload Structure is determined by the DataSchema elements. [TD] describes
            the use of the <code>DataSchema</code> keywords "schema", "inputSchema", and outputSchema
            in the examples contained in this document.
          </p>
          <p>
            In addition to the example pattern in [TD] of an object with name/value
            constructs or simple arrays, Protocol Bindings for existing standards
            may require nested arrays and objects, and some constant values to
            be specified.
          </p>
          <p>
            For example, a simple payload structure may use a map:
          </p>

          <p>
            <pre class="example" title="Simple Payload Structure">
              {
                "level": 50,
                "time": 10
              }
            </pre>

          <p>
            SenML might use the following construct:
          </p>

          <pre class="example" title="SenML Example">
            [
              {
                "bn": "/example/light/"
              },
              {
                "n": "level",
                "v": 50
              },
              {
                "n": "time",
                "v": 10
              }
            ]
          </pre>

          <p>
            A Batch Collection according to OCF may be structured like this:
          </p>

          <pre class="example" title="OCF Batch Example">
            [
              {
                "href": "/example/light/level",
                "rep": {
                  "dimming": 50
                }
              },
              {
                "href": "/example/light/time",
                "rep": {
                  "ramptime": 10
                }
              }
            ]
          </pre>

          <p>
            And an IPSO Smart Object on LWM2M might look like the following:
          </p>

          <pre class="example" title="IPSO/LWM2M Example">
            {
              "bn": "/3001/0/",
              "e": [
                {
                  "n": "5044",
                  "v": 0.5
                },
                {
                  "n": "5002",
                  "v": 10.0
                }
              ]
            }
          </pre>

          <p>
            The Protocol Binding template for each of these payloads will be
            structured according to the desired payload structure.
          </p>

          <p>
            For the Simple Payload in Example 1 above, the data schema element would
            be structured as follows:
          </p>

          <pre class="example" title="data Schema for Simple JSON Object Payload">
            {
              "schema": {
                "type": "object",
                "field": [
                  {
                    "name": "level",
                    "@type": ["iot:LevelData],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 255
                    }
                  },
                  {
                    "name": "time",
                    "@type": ["iot:TransitionTimeData"],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 65535
                    }
                  }
                ]
              }
            }
          </pre>

          <p>
            For the SenML Payload in Example 2 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for SenML Payload">
            {
              "schema": {
                "type": "array",
                "items": {
                  "allOf": [
                    {
                      "type": "object",
                      "field": [
                        {
                          "name": "bn",
                          "schema": {
                            "type": "string",
                            "const": "example/light"
                          }
                        }
                      ]
                    },
                    {
                      "type": "object",
                      "field": [
                        {
                          "name": "n",
                          "schema": {
                            "type": "string",
                            "const": "level"
                          }
                        },
                        {
                          "name": "v",
                          "@type": ["iot:LevelData"],
                          "schema": {
                            "type": "integer",
                            "minimum": 0,
                            "maximum": 255
                          }
                        }
                      ]
                    },
                    {
                      "type": "object",
                      "field": [
                        {
                          "name": "n",
                          "schema": {
                            "type": "string",
                            "const": "time"
                          }
                        },
                        {
                          "name": "v",
                          "@type": ["iot:TransitionTimeData"],
                          "schema": {
                            "type": "integer",
                            "minimum": 0,
                            "maximum": 65535
                          }
                        }
                      ]
                    }
                  ]
                }
              }
            }
          </pre>

          <p>
            For the OCF Batch Payload in Example 3 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for OCF Batch Payload">
            {
              "schema": {
                "type": "array",
                "items": {
                  "allOf": [
                    {
                      "type": "object",
                      "field": [
                        {
                          "name": "href",
                          "schema": {
                            "type": "string",
                            "const": "/light/level"
                          }
                        },
                        {
                          "name": "rep",
                          "type": "object",
                          "field": [
                            {
                              "name": "dimming",
                              "@type": ["iot:LevelData"],
                              "schema": {
                                "type": "integer",
                                "minimum": 0,
                                "maximum": 255
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "object",
                      "field": [
                        {
                          "name": "href",
                          "schema": {
                            "type": "string",
                            "const": "/light/time"
                          }
                        },
                        {
                          "name": "rep",
                          "schema": {
                            "type": "object",
                            "field": [
                              {
                                "name": "ramptime",
                                "@type": ["iot:TransitionTimeData"],
                                "schema": {
                                  "type":"integer",
                                  "minimum": 0,
                                  "maximum": 65535
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  ]
                }
              }
            }
          </pre>

          <p>
            For the IPSO/LWM2M Payload in Example 4 above, the <code>DataSchema</code> element would
            be structured as follows:
          </p>

          <pre class="example" title="DataSchema for IPSO/LWM2M Payload">
            {
              "schema": {
                "type": "object",
                "field": [
                  {
                    "name": "bn",
                    "schema": {
                      "type": "string",
                      "const": "/3001/0/"
                    }
                  },
                  {
                    "name": "e",
                    "type": "array",
                    "items": {
                      "allOf": [
                        {
                          "type": "object",
                          "field": [
                            {
                              "name": "n",
                              "schema": {
                                "type": "string",
                                "const": "5044"
                              }
                            },
                            {
                              "name": "v",
                              "@type": ["iot:LevelData"],
                              "schema": {
                                "type": "number",
                                "minimum": 0.0,
                                "maximum": 1.0
                              }
                            }
                          ]
                        },
                        {
                          "type": "object",
                          "field": [
                            {
                              "name": "n",
                              "schema": {
                                "type": "string",
                                "const": "5002"
                              }
                            },
                            {
                              "name": "v",
                              "@type": ["iot:TransitionTimeData"],
                              "schema": {
                                "type": "number",
                                "minimum": 0.0,
                                "maximum": 6553.5
                              }
                            }
                          ]
                        }
                      ]
                    }
                  }
                ]
              }
            }
          </pre>
        </section>

        <section id="data-types-constraints">
          <h2>Data Types and value constraints</h2>
          <p>
            Note that in Example 5 above, the values are floating point while the
            other examples have integer values. It is up to the client to adapt to
            the range and type as well as the engineering units provided.
          </p>
        </section>

      </section>

      <section id="form-element">
        <h2>Form Element</h2>
        <p>
          The "form" element contains the URI pointing to an instance of the interaction
          and descriptions of the protocol settings and options expected to be used when
          between the client and server for the interaction.
        </p>

        <section id="relation-types">
          <h2>Relation Types</h2>
          <p>
            Form Relation Types describe the expected result of performing the operation
            described by the form.
          </p>
          <p>
            For example, the Property interaction allows read and write operations. The
            protocol binding may contain a form for the read operation and a different
            form for the write operation. The value of the "rel" attribute of the form
            indicates which form is which and allows the client to select the correct
            form for the operation required.
          </p>

          <pre class="example" title="Form Relation Types">
            "rel": "readProperty"
            "rel": "writeProperty"
          </pre>

          <p>
            The vocabulary in section 5 lists the recommended set of form relations,
            and the full TD examples in section 6 contain example uses of form relation types.
          </p>
        </section>

        <section id="media-types">
          <h2>Media Types</h2>
          <p>
            Media Types define the serialization details and other rules for processing
            the payloads. The media type is used to select a serializer/deserializer
            and to select an additional set of rules and constraints for the protocol
            driver.
          </p>
          <p>
            For example, the mediaType "application/ocf+cbor" indicates that CBOR
            serialization is used, but also that OCF rules and namespaces
            apply to the processing of the representations.
          </p>
          <p>
            Additionally, there may be a profile which points to a URI for
            further description, for example a form with
            profile=http://iotschema.org/protocols/ipso.jsonld indicates that the
            target representation follows a set of additional encoding rules and
            constraints which are further defined at the URI by the profile
            attribute's value.
          </p>
          <p>
            Some special protocol drivers may be invoked by using a non-registered
            media type e.g. x-<echonet> along with a custom URI scheme and its own
            set of protocol methods and options defined for that URI scheme.
          </p>
        </section>

        <section id="protocol-methods-options">
          <h2>Protocol Methods and Options</h2>
          <p>
            Each target protocol may specify different method names for similar
            methods, and there may be semantic differences between similar methods of
            different protocols. Additionally, will use different methods
            for mapping to a particular WoT Interaction type. For example, POST may
            be used for setting a property value in one protocol, while PUT may be
            used in another. For these reasons, we require the ability to specify
            which method to use for a particular interaction. We also will provide
            vocabulary to differentiate between methods of different protocols.
          </p>
          <p>
            The W3C RDF vocabulary for HTTP [ref] is used to identify the methods
            and options specified in the HTTP protocol bindings.
          </p>
          <p>
            For the sake of consistency, we will use the same ontology design pattern
            to derive a vocabulary for each target protocol, e.g. CoAP, MQTT.
          </p>

          <p>
            The example below shows some method definitions for various protocols.
          </p>

          <pre class="example" title="Vocabulary Example for Methods">
            "http:methodName": "get"

            "mqtt:methodName": "subscribe"

            "coap:methodCode": "0.01"
          </pre>

          <p>
            Header options in HTTP, CoAP, MQTT sometimes must be included in a
            protocol binding in order to successfully interact with the underlying
            protocol. The example below shows the structure of the definition for
            http header options, according to the W3C HTTP Vocabulary in RDF.
          </p>

          <pre class="example" title="HTTP Vocabulary Example for Header Options">
            "http:headers":
              [
                {
                  "http:fieldName": "Accept",
                  "http:fieldValue": "application/json"
                },
                {
                  "http:fieldName": "Transfer-Encoding",
                  "http:fieldValue": "chunked"
                }
              ]
          </pre>
          <p>
            Note: different forms in a binding may need different header constructions,
            therefore the <code>headers</code> construct is an extension of the TD "form" element.
          </p>
          <p>
            Protocols may have defined sub-protocols that can be used for some interaction
            types. For example, to recieve asynchronous notifications using http, some
            servers may support long polling, EventSource, or a simple non-multiplexed
            websocket protocol.

            The "subProtocol" item may be defined in a form instance to indicate the
            use of one of these protocols, for example:
            <pre class="example" title="subProtocol">
              {
              "subProtocol": "LongPoll"
              }
            </pre>

            </thead>
          </p>


        </section>

    </section>


    <section id="Interaction Types" class="informative">
      <h1>Interaction Types</h1>
      <p>
        This section describes unique aspects of protocol bindings for the three
        WoT interaction types.
      </p>

      <section id="property-bindings">
        <h2>Bindings for Properties</h2>
        <p>
          This section describes unique aspects of protocol bindings for
          WoT Property type interactions.
        </p>
        <p>
          The abstract methods exposed for the Property Interaction are readProperty,
          writeProperty, and observe. These are mapped by using form relations that describe
          the abstract method, resulting in a semantic interpretation similar to
          HTML form submission.
        </p>
        <pre class="example" title="Example use of form relation for Property">
          <p>
            For example a form having href=/example/level, rel=writeProperty, and
            http:methodName=post conveys the statement:
          </p>
          <p>
            To do a writeProperty of the subject Property (context of the form),
            perform a post on the resource at the target URI /example/level.
          </p>
        </pre>
        <p>
          Properties may be observable, defined by the TD keyword "observable".
          If there is an observe form and a retrieve form, the observe form may be
          indicated by including rel=observe in the form. The observe form may
          also specify header options to use, for example CoAP observe option=0
          in the header to start observation.
        </p>
      </section>

      <section id="action-bindings" class="informative">
        <h2>Bindings for Actions</h2>
        <p>
          This section describes unique aspects of protocol bindings for WoT
          Action type interactions.
        </p>
        <p>
          The abstract methods on Actions are invokeAction, modifyAction, and
          cancelAction. In the same way that the abstract methods on properties are
          mapped using form relations, the abstract methods of actions are also
          mapped.
        </p>
        <pre class="example" title="Example use of form relation for Action">
          <p>
            For example a form with href=/example/levelaction, rel=invokeAction,
            and http:methodName=post conveys the statement:
          </p>
          <p>
            To do an invokeAction of the subject Action (context of the form),
            perform a post on the resource at /example/levelaction.
          </p>
        </pre>
        <p>
          If the Action returns a handle to a created item, the protocol
          binding may indicate the manner in which the location or handle of the
          item is returned to the client by using the "expects" item in the form
          to describe the returned information.
        </p>
      </section>

      <section id="event-bindings" class="informative">
        <h2>Bindings for Events</h2>
        <p>
          This section describes unique aspects of protocol bindings for WoT
          Event type interactions.
        </p>
        <p>
          The abstract methods on Events are subscribeEvent, unsubscribeEvent, and
          observe.
          The subscribeEvent operation returns a location or resource URI from which
          events may be obtained, either by observation or some other method.
        </p>
        <p>
          The binding for Events allows either pre-defined URIs to observable or
          pubsub resources, or the pattern of subscription creation which returns
          an observable or pubsub URI.
        </p>
        <p>
          If the binding offers a subscription, there will be a form with
          rel=subscribeEvent
        </p>
        <p>
          If the binding offers an observable Event resource from which events are
          obtained directly, there will be a form with rel=wot:observe
        </p>
        <pre class="example" title="Example use of form relation for Events">
          <p>
            For example a form having href=/example/levelevent, rel=subscribeEvent,
            and http:methodName=post conveys the statement:
          </p>
          <p>
            To do a subscribeEvent of the subject Event (context of the form),
            perform a post on the resource at /example/levelevent.
          </p>
        </pre>
        <p>
          If the Event supports subscription, the protocol binding may indicate the
          manner in which the location of the event source is returned to the client.
        </p>
      </section>

    </section>

    <section id="processing-model" class="informative">
      <h1>Processing Model and Runtime</h1>
      <p>
        This section describes the processing model for Protocol Bindings with
        respect to the abstract WoT Interactions provided by the Scripting API.
      </p>
      <p>
        <code>DataSchema</code> elements are processed, and value scaling is
        performed, in the application library or adaptation layer.
      </p>
      <p>
        Form elements that specify href, method, options, and mediaType are
        processed in a driver context which is isolated from the application.
      </p>
      <p>
        The application, or a protocol adaptation layer, constructs an instance of
        the appropriate DataSchema element
        and sends it along with the selected form contents to the protocol driver
        or, in the case of get, receives a payload form the protocol driver and
        uses the appropriate <code>DataSchema</code> element to extract the field values of interest.
      </p>
      <p>
        The separation of execution context between the application and the protocol
        driver enables isolation of fault domains and isolation of security domains.
      </p>
      <p>
        Binding for Secure communications, Security Binding
      </p>
      <p>
        Binding for Proxy Thing and Exposed Thing, Proxy Binding
      </p>
    </section>

    </section>

    <section id="vocabulary" class="informative">
      <h1>Vocabulary</h1>
        <p>
          This section specifies the vocabulary for protocol binding templates
        </p>
        <section>
          <h2><code>DataSchema</code> Vocabulary</h2>
            <p>
              <code>DataSchema</code> elements describe the structure of the payload.
              The <code>DataSchema</code>
              vocabulary is described in [TD]. Properties and Events define a "schema"
              for data transfer in either direction. Actions may define "inputSchema"
              for actuation data being sent to the resource using, for example, POST or
              PUT, and "outputSchema" for result or status data being returned from
              the Action resource.
            </p>
        </section>

        <section>
          <h2>Interaction Verbs</h2>
            <p>
              Interactions have one or more defined interaction verbs for each
              interaction pattern. Form Relations allow an interaction to have
              separate protocol mechanisms to support different interaction verbs.
            </p>
          <section>
            <h3>Property Interactions</h3>
              <p>
                Properties provide '"read" and, optionally, "write"
                operations, which map to GET and PUT/POST of a REST API.
                Properties may also by observed, though some properties may not be
                observable.
              </p>
              <p>
                readProperty
              </p>
              <p>
                writeProperty
              </p>
              <p>
                observeProperty
              </p>
            </section>

          <section>
            <h3>Action Interactions</h3>
              <p>
                Actions provide '"invoke" and, optionally, "cancel" or "update"
                operations, which can also map to GET, PUT, POST, and DELETE of a
                REST API.
              </p>
              <p>
                invokeAction
              </p>
          </section>

          <section>
            <h3>Event Interactions</h3>
              <p>
                Events may directly expose observable resources from which to obtain event
                instances.
                Events may provide '"subscribe" operations to create subscription
                resources, which may in turn be observed in order to obtain the events.
              </p>
              <p>
                subscribeEvent
              </p>
              <p>
                cancelSubscription
              </p>
            </section>
          </section>

          <section>
          <h2>Form Vocabulary</h2>
            <p>
              Extensions to the form vocabulary provide a way to inform the client about
              protocol methods, options, and status codes.
            </p>
            <section>
              <h3>HTTP form vocabulary</h3>
                <p>
                  http:methodName [ "GET", "PUT", "POST", "DELETE"]
                </p>
                <p>
                  http:headers
                  example: [ {"http:fieldName": "accept", "http:fieldValue": "text/plain"} ]
                </p>
                <p>
                  http:fieldName [ accept, content-type, transfer-encoding ]
                </p>
                <p>
                  http:fieldValue
                </p>
            </section>
            <section>
              <h3>CoAP form vocabulary</h3>
                <p>
                  coap:methodCode [ "0.01", "0.02", "0.03", "0.04" ]
                </p>
                <p>
                  coap:options
                  example: [ { "coap:optionCode": 6, "coap:optionValue": 49 } ]
                </p>
                <p>
                  coap:optionCode
                </p>
                <p>
                  coap:optionValue
                </p>
            </section>

            <section>
              <h3>MQTT form vocabulary</h3>
                <p>
                  mqtt:methodName [ "PUBLISH", "SUBSCRIBE" ]
                </p>
                <p>
                  mqtt:options
                  example: [ {  "mqtt:optionName": "qos", "mqtt:optionValue": 1 }]
                </p>
                <p>
                  mqtt:optionName [ qos, retain ]
                </p>
                <p>
                  mqtt:optionValue
                </p>
            </section>

            <section>
              <h3>subProtocol form vocabulary</h3>
                <p>
                  subProtocol [ "LongPoll", "EventSource", "WebSocket" ]
                </p>
            </section>

          </section>

    </section>

    <section id="binding-examples" class="informative">
      <h1>Examples of Thing Descriptions including protocol bindings</h1>
      <p>
        TD with simple payload format
      </p>
      <pre class="example" title="TD with a simple Payload">
        {
          "@context": [
            "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
            "https://w3c.github.io/wot/w3c-wot-common-context.jsonld",
        	  {
              "iot": "http://iotschema.org/",
              "http": "http://iotschema.org/protocol/http",
              "coap": "http://iotschema.org/protocol/coap",
              "mqtt": "http://iotschema.org/protocol/mqtt"
            }
          ],
          "@type": [ "Thing", "iot:Light", "iot:LevelCapability", "iot:BinarySwitch" ],
          "base": "http://example.com",
          "name": "Lamp",
          "interaction": [
            {
              "name": "Switch State",
              "@type": ["Property", "iot:SwitchStatus"],
              "schema":  {
                "@type": ["iot:SwitchData"],
                "type": "boolean"
              },
              "writable": false,
              "observable": false,
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["readData", "writeData"],
                  "mediaType": "application/json"
                }
              ]
            },
            {
              "name": "Current brightness",
              "@type": ["Property", "iot:CurrentLevel"],
              "schema":  {
                "@type": ["iot:LevelData"],
                "type": "number"
              },
              "writable": false,
              "observable": false,
              "form": [
                {
                  "href": "/example/light/currentdimmer",
                  "rel": ["readData", "writeData"],
                  "mediaType": "application/json"
                }
              ]
            },
            {
              "name": "Switch On",
              "@type": ["Action", "iot:SwitchOn"],
              "inputSchema":  {
                "type": "boolean",
                "const": true
              },
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["invokeAction"],
                  "mediaType": "application/json"
                }
              ]
            },
            {
              "name": "Switch Off",
              "@type": ["Action", "iot:SwitchOff"],
              "inputSchema":  {
                "type": "boolean",
                "const": false
              },
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "rel": ["invokeAction"],
                  "mediaType": "application/json"
                }
              ]
            },
            {
              "name": "Set brightness level",
              "@type": ["Action", "iot:SetLevel"],
              "inputSchema":  {
                "@type": ["iot:LevelData"],
                "type": "number"
              },
              "form": [
                {
                  "href": "/example/light/currentdimmer",
                  "rel": ["invokeAction"],
                  "mediaType": "application/json"
                }
              ]
            }
          ]
        }
      </pre>
      <p>
        TD with complex payload and multiple protocol options
      </p>
      <pre class="example" title="TD with protocol options and complex payload">
        {
          "@context": [
            "https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
            "https://w3c.github.io/wot/w3c-wot-common-context.jsonld",
            {
              "iot": "http://iotschema.org/",
              "http": "http://iotschema.org/protocol/http",
              "coap": "http://iotschema.org/protocol/coap",
              "mqtt": "http://iotschema.org/protocol/mqtt"
            }
          ],
          "base": "http://example.com/",
          "@type": [ "Thing", "iot:Light", "iot:LevelCapability", "iot:BinarySwitch" ],
          "name": "Lamp",
          "interaction": [
            {
              "name": "Switch State",
              "@type": ["Property", "iot:SwitchStatus"],
              "schema":  {
                "type": "object",
                "field": [
                  {
                    "name": "switch",
                    "@type": ["iot:SwitchData"],
                    "schema": {
                      "type": "boolean"
                    }
                  }
                ]
              },
              "writable": true,
              "observable": true,
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["readProperty"],
                  "http:methodName": "http:get"
                },
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["writeProperty"],
                  "http:methodName": "http:post"
                },
                {
                  "href": "mqtt://example.com/example/light/currentswitch",
                  "rel": ["observe"],
                  "mqtt:methodName": "mqtt:subscribe"
                }
              ]
            },
            {
              "name": "Current brightness",
              "@type": ["Property", "iot:CurrentLevel"],
              "schema": {
                "type": "object",
                "field": [
                  {
                    "name": "brightness",
                    "@type": ["iot:LevelData" ],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 255
                    }
                  }
                ]
              },
              "writable": true,
              "observable": true,
              "form": [
                {
                  "href": "/example/light/currentdimmer",
                  "mediaType": "application/json",
                  "rel": ["readProperty"],
                  "http:methodName": "http:get"
                },
                {
                  "href": "/example/light/currentdimmer",
                  "mediaType": "application/json",
                  "rel": ["writeProperty"],
                  "http:methodName": "http:post"
                },
                {
                  "href": "mqtt://example.com/example/light/currentdimmer",
                  "rel": ["observe"],
                  "mqtt:methodName": "mqtt:subscribe"
                }
              ]
            },
            {
              "name": "Transition Time",
              "@type": ["Property", "iot:TransitionTime"],
              "schema": {
                "type": "object",
                "field": [
                  {
                    "name": "transitiontime",
                    "@type": ["iot:TransitionTimeData" ],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 255
                    }
                  }
                ]
              },
              "writable": true,
              "observable": false,
              "form": [
                {
                  "href": "/example/light/transitiontime",
                  "mediaType": "application/json",
                  "rel": ["readProperty"],
                  "http:methodName": "http:get"
                },
                {
                  "href": "/example/light/transitiontime",
                  "mediaType": "application/json",
                  "rel": ["writeProperty"],
                  "http:methodName": "http:post"
                }
              ]
            },
            {
              "name": "Switch On",
              "@type": ["Action", "iot:SwitchOn"],
              "inputSchema":  {
                "type": "object",
                "field": [
                  {
                    "name": "switch",
                    "schema":{
                      "type": "boolean",
                      "const": true
                    }
                  }
                ]
              },
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["invokeAction"],
                  "http:methodName": "http:post"
                }
              ]
            },
            {
              "name": "Switch Off",
              "@type": ["Action", "iot:SwitchOff"],
              "inputSchema":  {
                "type": "object",
                "field": [
                  {
                    "name": "switch",
                    "schema": {
                      "type": "boolean",
                      "const": false
                    }
                  }
                ]
              },
              "form": [
                {
                  "href": "/example/light/currentswitch",
                  "mediaType": "application/json",
                  "rel": ["invokeAction"],
                  "http:methodName": "http:post"
                }
              ]
            },
            {
              "name": "Set brightness level",
              "@type": ["Action", "iot:SetLevel"],
              "inputSchema": {
                "type": "object",
                "field": [
                  {
                    "name": "brightness",
                    "@type": ["iot:LevelData"],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 255
                    }
                  },
                  {
                    "name": "transitiontime",
                    "@type": ["iot:TransitionTimeData"],
                    "schema": {
                      "type": "integer",
                      "minimum": 0,
                      "maximum": 65535
                    }
                  }
                ]
              },
              "form": [
                {
                  "href": "/example/light/",
                  "mediaType": "application/json",
                  "rel": ["invokeAction"],
                  "http:methodName": "http:post"
                }
              ]
            }
          ]
        }
      </pre>

    </section>


    <section id="references" class="informative">
      <h1>References</h1>
      <p>
        IANA link relations
        https://www.iana.org/assignments/link-relations/link-relations.xhtml
      </p>
      <p>
        "profile" relation
        https://tools.ietf.org/html/rfc6906
      </p>
      <p>
       A media type defines both the semantics and the serialization of a
       specific type of content.  In many cases, media types have some
       built-in extensibility or openness, so that specific instances of the
       media type can layer additional semantics on top of the media type's
       foundation.  In this case, a profile is the appropriate mechanism to
       signal that the original semantics and processing model of the media
       type still apply, but that an additional processing model can be used
       to extract additional semantics.
      </p>
      <p>
        HTTP vocabulary
      </p>

    </section>


    <section id="sec-security-considerations">
      <h1>Security and Privacy Considerations</h1>
      <p class="ednote">
        Security and privacy considerations are still under discussion and development; the content below should be considered preliminary.
        Due to the complexity of the subject
        we are considering producing a separate document containing a detailed security and privacy considerations discussion
        including a risk analysis,
        threat model,
        recommended mitigations,
        and appropriate references to best practices.
        A summary will be included here.
        Work in progress is located in the
        <a href="https://github.com/w3c/wot-security/">WoT Security and Privacy</a> repository.
        Please file any security or privacy considerations and/or concerns using the <a href="https://github.com/w3c/wot-security/issues">GitHub Issue</a> feature.
      </p>
      <p><!-- Security requirements for the the WoT -->
        Security is a cross-cutting issue that needs to be taken into account in all
        <a href="#sec-building-blocks">WoT building blocks</a>.
        The W3C WoT does not define any new security mechanisms,
        but provides guidelines to apply the best practices from
        Web security,
        IoT security,
        and information security for general software and hardware considerations.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing-description-td">WoT Thing Description</a> must be used together with integrity protection mechanisms and access control policies.
        Users must ensure that no sensitive information is included in the <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-td">TDs</a> themselves.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-binding-templates">WoT Binding Templates</a> must correctly cover the security mechanisms employed by the underlying <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-iot-platform">IoT Platform</a>.
        Due to the automation of network interactions necessary in the IoT, operators need to ensure that <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-thing">Things</a> are exposed and consumed in a way that is compliant with their security policies.
      </p>
      <p>
        The <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-wot-runtime">WoT Runtime</a> implementation for the <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-scripting-api">WoT Scripting API</a> must have mechanisms to prevent malicious access to the system and isolate scripts in multi-tenant <a href="https://github.com/w3c/wot-architecture/blob/master/terminology.md#user-content-servient">Servients</a>.
      </p>
    </section>


    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        Special thanks to all active Participants of the W3C Web of Things Interest Group and Working Group
        for their technical input and suggestions that led to improvements to this document.
      </p>
    </section>
<!--
    <section class="appendix">
      <h2>Change History</h2>
      <p>
        This is the First Public Working Draft.
      </p>
    </section>
-->
    <script  id="dstimer"  language="javascript">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
    </script>
  </body>
</html>
